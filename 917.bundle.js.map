{"version":3,"file":"917.bundle.js","mappings":"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","sources":["webpack://ol-mbtiles/./node_modules/sqlite-wasm-http/dist/endianness.js","webpack://ol-mbtiles/./node_modules/sqlite-wasm-http/dist/vfs-http-types.js","webpack://ol-mbtiles/./node_modules/sqlite-wasm-http/node_modules/lru-cache/index.mjs"],"sourcesContent":["// Procedures for changing the byte sex\n// SQLite is always Big-Endian, JS follows the platform, which is Little-Endian on x86\nimport { debug } from './vfs-http-types.js';\nconst swapNeeded = (function () {\n    const ab = new ArrayBuffer(2);\n    const u8 = new Uint8Array(ab);\n    const u16 = new Uint16Array(ab);\n    u8[0] = 0xF0;\n    u8[1] = 0x0D;\n    // Big\n    if (u16[0] == 0xF00D) {\n        debug['threads']('System is Big-Endian');\n        return false;\n    }\n    // Little\n    if (u16[0] == 0x0DF0) {\n        debug['threads']('System is Little-Endian');\n        return true;\n    }\n    throw new Error(`Failed determining endianness: ${u16}`);\n})();\nexport function ntoh16(data) {\n    if (swapNeeded) {\n        for (let i = 0; i < data.length; i++) {\n            data[i] = ((data[i] & 0xFF00) >> 8) | ((data[i] & 0x00FF) << 8);\n        }\n    }\n}\n//# sourceMappingURL=endianness.js.map","var _a;\nexport const defaultOptions = {\n    timeout: 20000,\n    maxPageSize: 4096,\n    cacheSize: 1024,\n    headers: {}\n};\n// These must be different from any SQLite CAPI codes\nexport var SYNC;\n(function (SYNC) {\n    SYNC[SYNC[\"WORKMSG\"] = 16777215] = \"WORKMSG\";\n    SYNC[SYNC[\"HANDSHAKE\"] = 16777214] = \"HANDSHAKE\";\n})(SYNC = SYNC || (SYNC = {}));\nconst debugOptions = (typeof SQLITE_DEBUG !== 'undefined' && SQLITE_DEBUG) ||\n    (typeof process !== 'undefined' && typeof ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.SQLITE_DEBUG) !== 'undefined' && process.env.SQLITE_DEBUG) ||\n    '';\nexport const debugSys = ['threads', 'vfs', 'cache', 'http'];\nexport const debug = {};\nfor (const d of debugSys) {\n    debug[d] = debugOptions.includes(d) ?\n        console.debug.bind(console) :\n        () => undefined;\n}\n//# sourceMappingURL=vfs-http-types.js.map","const perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n\nconst hasAbortController = typeof AbortController === 'function'\n\n// minimal backwards-compatibility polyfill\n// this doesn't have nearly all the checks and whatnot that\n// actual AbortController/Signal has, but it's enough for\n// our purposes, and if used properly, behaves the same.\nconst AC = hasAbortController\n  ? AbortController\n  : class AbortController {\n      constructor() {\n        this.signal = new AS()\n      }\n      abort(reason = new Error('This operation was aborted')) {\n        this.signal.reason = this.signal.reason || reason\n        this.signal.aborted = true\n        this.signal.dispatchEvent({\n          type: 'abort',\n          target: this.signal,\n        })\n      }\n    }\n\nconst hasAbortSignal = typeof AbortSignal === 'function'\n// Some polyfills put this on the AC class, not global\nconst hasACAbortSignal = typeof AC.AbortSignal === 'function'\nconst AS = hasAbortSignal\n  ? AbortSignal\n  : hasACAbortSignal\n  ? AC.AbortController\n  : class AbortSignal {\n      constructor() {\n        this.reason = undefined\n        this.aborted = false\n        this._listeners = []\n      }\n      dispatchEvent(e) {\n        if (e.type === 'abort') {\n          this.aborted = true\n          this.onabort(e)\n          this._listeners.forEach(f => f(e), this)\n        }\n      }\n      onabort() {}\n      addEventListener(ev, fn) {\n        if (ev === 'abort') {\n          this._listeners.push(fn)\n        }\n      }\n      removeEventListener(ev, fn) {\n        if (ev === 'abort') {\n          this._listeners = this._listeners.filter(f => f !== fn)\n        }\n      }\n    }\n\nconst warned = new Set()\nconst deprecatedOption = (opt, instead) => {\n  const code = `LRU_CACHE_OPTION_${opt}`\n  if (shouldWarn(code)) {\n    warn(code, `${opt} option`, `options.${instead}`, LRUCache)\n  }\n}\nconst deprecatedMethod = (method, instead) => {\n  const code = `LRU_CACHE_METHOD_${method}`\n  if (shouldWarn(code)) {\n    const { prototype } = LRUCache\n    const { get } = Object.getOwnPropertyDescriptor(prototype, method)\n    warn(code, `${method} method`, `cache.${instead}()`, get)\n  }\n}\nconst deprecatedProperty = (field, instead) => {\n  const code = `LRU_CACHE_PROPERTY_${field}`\n  if (shouldWarn(code)) {\n    const { prototype } = LRUCache\n    const { get } = Object.getOwnPropertyDescriptor(prototype, field)\n    warn(code, `${field} property`, `cache.${instead}`, get)\n  }\n}\n\nconst emitWarning = (...a) => {\n  typeof process === 'object' &&\n  process &&\n  typeof process.emitWarning === 'function'\n    ? process.emitWarning(...a)\n    : console.error(...a)\n}\n\nconst shouldWarn = code => !warned.has(code)\n\nconst warn = (code, what, instead, fn) => {\n  warned.add(code)\n  const msg = `The ${what} is deprecated. Please use ${instead} instead.`\n  emitWarning(msg, 'DeprecationWarning', code, fn)\n}\n\nconst isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n)\n\n/* istanbul ignore next - This is a little bit ridiculous, tbh.\n * The maximum array length is 2^32-1 or thereabouts on most JS impls.\n * And well before that point, you're caching the entire world, I mean,\n * that's ~32GB of just integers for the next/prev links, plus whatever\n * else to hold that many keys and values.  Just filling the memory with\n * zeroes at init time is brutal when you get that big.\n * But why not be complete?\n * Maybe in the future, these limits will have expanded. */\nconst getUintArray = max =>\n  !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n    ? Uint8Array\n    : max <= Math.pow(2, 16)\n    ? Uint16Array\n    : max <= Math.pow(2, 32)\n    ? Uint32Array\n    : max <= Number.MAX_SAFE_INTEGER\n    ? ZeroArray\n    : null\n\nclass ZeroArray extends Array {\n  constructor(size) {\n    super(size)\n    this.fill(0)\n  }\n}\n\nclass Stack {\n  constructor(max) {\n    if (max === 0) {\n      return []\n    }\n    const UintArray = getUintArray(max)\n    this.heap = new UintArray(max)\n    this.length = 0\n  }\n  push(n) {\n    this.heap[this.length++] = n\n  }\n  pop() {\n    return this.heap[--this.length]\n  }\n}\n\nclass LRUCache {\n  constructor(options = {}) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      fetchContext,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n    } = options\n\n    // deprecated options, don't trigger a warning for getting them if\n    // the thing being passed in is another LRUCache we're copying.\n    const { length, maxAge, stale } =\n      options instanceof LRUCache ? {} : options\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer')\n    }\n\n    const UintArray = max ? getUintArray(max) : Array\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max)\n    }\n\n    this.max = max\n    this.maxSize = maxSize\n    this.maxEntrySize = maxEntrySize || this.maxSize\n    this.sizeCalculation = sizeCalculation || length\n    if (this.sizeCalculation) {\n      if (!this.maxSize && !this.maxEntrySize) {\n        throw new TypeError(\n          'cannot set sizeCalculation without setting maxSize or maxEntrySize'\n        )\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function')\n      }\n    }\n\n    this.fetchMethod = fetchMethod || null\n    if (this.fetchMethod && typeof this.fetchMethod !== 'function') {\n      throw new TypeError(\n        'fetchMethod must be a function if specified'\n      )\n    }\n\n    this.fetchContext = fetchContext\n    if (!this.fetchMethod && fetchContext !== undefined) {\n      throw new TypeError(\n        'cannot set fetchContext without fetchMethod'\n      )\n    }\n\n    this.keyMap = new Map()\n    this.keyList = new Array(max).fill(null)\n    this.valList = new Array(max).fill(null)\n    this.next = new UintArray(max)\n    this.prev = new UintArray(max)\n    this.head = 0\n    this.tail = 0\n    this.free = new Stack(max)\n    this.initialFill = 1\n    this.size = 0\n\n    if (typeof dispose === 'function') {\n      this.dispose = dispose\n    }\n    if (typeof disposeAfter === 'function') {\n      this.disposeAfter = disposeAfter\n      this.disposed = []\n    } else {\n      this.disposeAfter = null\n      this.disposed = null\n    }\n    this.noDisposeOnSet = !!noDisposeOnSet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort\n    this.ignoreFetchAbort = !!ignoreFetchAbort\n\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.maxSize !== 0) {\n        if (!isPosInt(this.maxSize)) {\n          throw new TypeError(\n            'maxSize must be a positive integer if specified'\n          )\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError(\n          'maxEntrySize must be a positive integer if specified'\n        )\n      }\n      this.initializeSizeTracking()\n    }\n\n    this.allowStale = !!allowStale || !!stale\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.updateAgeOnHas = !!updateAgeOnHas\n    this.ttlResolution =\n      isPosInt(ttlResolution) || ttlResolution === 0\n        ? ttlResolution\n        : 1\n    this.ttlAutopurge = !!ttlAutopurge\n    this.ttl = ttl || maxAge || 0\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError(\n          'ttl must be a positive integer if specified'\n        )\n      }\n      this.initializeTTLTracking()\n    }\n\n    // do not allow completely unbounded caches\n    if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {\n      throw new TypeError(\n        'At least one of max, maxSize, or ttl is required'\n      )\n    }\n    if (!this.ttlAutopurge && !this.max && !this.maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED'\n      if (shouldWarn(code)) {\n        warned.add(code)\n        const msg =\n          'TTL caching without ttlAutopurge, max, or maxSize can ' +\n          'result in unbounded memory consumption.'\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)\n      }\n    }\n\n    if (stale) {\n      deprecatedOption('stale', 'allowStale')\n    }\n    if (maxAge) {\n      deprecatedOption('maxAge', 'ttl')\n    }\n    if (length) {\n      deprecatedOption('length', 'sizeCalculation')\n    }\n  }\n\n  getRemainingTTL(key) {\n    return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0\n  }\n\n  initializeTTLTracking() {\n    this.ttls = new ZeroArray(this.max)\n    this.starts = new ZeroArray(this.max)\n\n    this.setItemTTL = (index, ttl, start = perf.now()) => {\n      this.starts[index] = ttl !== 0 ? start : 0\n      this.ttls[index] = ttl\n      if (ttl !== 0 && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (this.isStale(index)) {\n            this.delete(this.keyList[index])\n          }\n        }, ttl + 1)\n        /* istanbul ignore else - unref() not supported on all platforms */\n        if (t.unref) {\n          t.unref()\n        }\n      }\n    }\n\n    this.updateItemAge = index => {\n      this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0\n    }\n\n    this.statusTTL = (status, index) => {\n      if (status) {\n        status.ttl = this.ttls[index]\n        status.start = this.starts[index]\n        status.now = cachedNow || getNow()\n        status.remainingTTL = status.now + status.ttl - status.start\n      }\n    }\n\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0\n    const getNow = () => {\n      const n = perf.now()\n      if (this.ttlResolution > 0) {\n        cachedNow = n\n        const t = setTimeout(\n          () => (cachedNow = 0),\n          this.ttlResolution\n        )\n        /* istanbul ignore else - not available on all platforms */\n        if (t.unref) {\n          t.unref()\n        }\n      }\n      return n\n    }\n\n    this.getRemainingTTL = key => {\n      const index = this.keyMap.get(key)\n      if (index === undefined) {\n        return 0\n      }\n      return this.ttls[index] === 0 || this.starts[index] === 0\n        ? Infinity\n        : this.starts[index] +\n            this.ttls[index] -\n            (cachedNow || getNow())\n    }\n\n    this.isStale = index => {\n      return (\n        this.ttls[index] !== 0 &&\n        this.starts[index] !== 0 &&\n        (cachedNow || getNow()) - this.starts[index] >\n          this.ttls[index]\n      )\n    }\n  }\n  updateItemAge(_index) {}\n  statusTTL(_status, _index) {}\n  setItemTTL(_index, _ttl, _start) {}\n  isStale(_index) {\n    return false\n  }\n\n  initializeSizeTracking() {\n    this.calculatedSize = 0\n    this.sizes = new ZeroArray(this.max)\n    this.removeItemSize = index => {\n      this.calculatedSize -= this.sizes[index]\n      this.sizes[index] = 0\n    }\n    this.requireSize = (k, v, size, sizeCalculation) => {\n      // provisionally accept background fetches.\n      // actual value size will be checked when they return.\n      if (this.isBackgroundFetch(v)) {\n        return 0\n      }\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function')\n          }\n          size = sizeCalculation(v, k)\n          if (!isPosInt(size)) {\n            throw new TypeError(\n              'sizeCalculation return invalid (expect positive integer)'\n            )\n          }\n        } else {\n          throw new TypeError(\n            'invalid size value (must be positive integer). ' +\n              'When maxSize or maxEntrySize is used, sizeCalculation or size ' +\n              'must be set.'\n          )\n        }\n      }\n      return size\n    }\n    this.addItemSize = (index, size, status) => {\n      this.sizes[index] = size\n      if (this.maxSize) {\n        const maxSize = this.maxSize - this.sizes[index]\n        while (this.calculatedSize > maxSize) {\n          this.evict(true)\n        }\n      }\n      this.calculatedSize += this.sizes[index]\n      if (status) {\n        status.entrySize = size\n        status.totalCalculatedSize = this.calculatedSize\n      }\n    }\n  }\n  removeItemSize(_index) {}\n  addItemSize(_index, _size) {}\n  requireSize(_k, _v, size, sizeCalculation) {\n    if (size || sizeCalculation) {\n      throw new TypeError(\n        'cannot set size without setting maxSize or maxEntrySize on cache'\n      )\n    }\n  }\n\n  *indexes({ allowStale = this.allowStale } = {}) {\n    if (this.size) {\n      for (let i = this.tail; true; ) {\n        if (!this.isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.isStale(i)) {\n          yield i\n        }\n        if (i === this.head) {\n          break\n        } else {\n          i = this.prev[i]\n        }\n      }\n    }\n  }\n\n  *rindexes({ allowStale = this.allowStale } = {}) {\n    if (this.size) {\n      for (let i = this.head; true; ) {\n        if (!this.isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.isStale(i)) {\n          yield i\n        }\n        if (i === this.tail) {\n          break\n        } else {\n          i = this.next[i]\n        }\n      }\n    }\n  }\n\n  isValidIndex(index) {\n    return (\n      index !== undefined &&\n      this.keyMap.get(this.keyList[index]) === index\n    )\n  }\n\n  *entries() {\n    for (const i of this.indexes()) {\n      if (\n        this.valList[i] !== undefined &&\n        this.keyList[i] !== undefined &&\n        !this.isBackgroundFetch(this.valList[i])\n      ) {\n        yield [this.keyList[i], this.valList[i]]\n      }\n    }\n  }\n  *rentries() {\n    for (const i of this.rindexes()) {\n      if (\n        this.valList[i] !== undefined &&\n        this.keyList[i] !== undefined &&\n        !this.isBackgroundFetch(this.valList[i])\n      ) {\n        yield [this.keyList[i], this.valList[i]]\n      }\n    }\n  }\n\n  *keys() {\n    for (const i of this.indexes()) {\n      if (\n        this.keyList[i] !== undefined &&\n        !this.isBackgroundFetch(this.valList[i])\n      ) {\n        yield this.keyList[i]\n      }\n    }\n  }\n  *rkeys() {\n    for (const i of this.rindexes()) {\n      if (\n        this.keyList[i] !== undefined &&\n        !this.isBackgroundFetch(this.valList[i])\n      ) {\n        yield this.keyList[i]\n      }\n    }\n  }\n\n  *values() {\n    for (const i of this.indexes()) {\n      if (\n        this.valList[i] !== undefined &&\n        !this.isBackgroundFetch(this.valList[i])\n      ) {\n        yield this.valList[i]\n      }\n    }\n  }\n  *rvalues() {\n    for (const i of this.rindexes()) {\n      if (\n        this.valList[i] !== undefined &&\n        !this.isBackgroundFetch(this.valList[i])\n      ) {\n        yield this.valList[i]\n      }\n    }\n  }\n\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  find(fn, getOptions) {\n    for (const i of this.indexes()) {\n      const v = this.valList[i]\n      const value = this.isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      if (fn(value, this.keyList[i], this)) {\n        return this.get(this.keyList[i], getOptions)\n      }\n    }\n  }\n\n  forEach(fn, thisp = this) {\n    for (const i of this.indexes()) {\n      const v = this.valList[i]\n      const value = this.isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.keyList[i], this)\n    }\n  }\n\n  rforEach(fn, thisp = this) {\n    for (const i of this.rindexes()) {\n      const v = this.valList[i]\n      const value = this.isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.keyList[i], this)\n    }\n  }\n\n  get prune() {\n    deprecatedMethod('prune', 'purgeStale')\n    return this.purgeStale\n  }\n\n  purgeStale() {\n    let deleted = false\n    for (const i of this.rindexes({ allowStale: true })) {\n      if (this.isStale(i)) {\n        this.delete(this.keyList[i])\n        deleted = true\n      }\n    }\n    return deleted\n  }\n\n  dump() {\n    const arr = []\n    for (const i of this.indexes({ allowStale: true })) {\n      const key = this.keyList[i]\n      const v = this.valList[i]\n      const value = this.isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      const entry = { value }\n      if (this.ttls) {\n        entry.ttl = this.ttls[i]\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - this.starts[i]\n        entry.start = Math.floor(Date.now() - age)\n      }\n      if (this.sizes) {\n        entry.size = this.sizes[i]\n      }\n      arr.unshift([key, entry])\n    }\n    return arr\n  }\n\n  load(arr) {\n    this.clear()\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset.\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start\n        entry.start = perf.now() - age\n      }\n      this.set(key, entry.value, entry)\n    }\n  }\n\n  dispose(_v, _k, _reason) {}\n\n  set(\n    k,\n    v,\n    {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      status,\n    } = {}\n  ) {\n    size = this.requireSize(k, v, size, sizeCalculation)\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss'\n        status.maxEntrySizeExceeded = true\n      }\n      // have to delete, in case a background fetch is there already.\n      // in non-async cases, this is a no-op\n      this.delete(k)\n      return this\n    }\n    let index = this.size === 0 ? undefined : this.keyMap.get(k)\n    if (index === undefined) {\n      // addition\n      index = this.newIndex()\n      this.keyList[index] = k\n      this.valList[index] = v\n      this.keyMap.set(k, index)\n      this.next[this.tail] = index\n      this.prev[index] = this.tail\n      this.tail = index\n      this.size++\n      this.addItemSize(index, size, status)\n      if (status) {\n        status.set = 'add'\n      }\n      noUpdateTTL = false\n    } else {\n      // update\n      this.moveToTail(index)\n      const oldVal = this.valList[index]\n      if (v !== oldVal) {\n        if (this.isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'))\n        } else {\n          if (!noDisposeOnSet) {\n            this.dispose(oldVal, k, 'set')\n            if (this.disposeAfter) {\n              this.disposed.push([oldVal, k, 'set'])\n            }\n          }\n        }\n        this.removeItemSize(index)\n        this.valList[index] = v\n        this.addItemSize(index, size, status)\n        if (status) {\n          status.set = 'replace'\n          const oldValue =\n            oldVal && this.isBackgroundFetch(oldVal)\n              ? oldVal.__staleWhileFetching\n              : oldVal\n          if (oldValue !== undefined) status.oldValue = oldValue\n        }\n      } else if (status) {\n        status.set = 'update'\n      }\n    }\n    if (ttl !== 0 && this.ttl === 0 && !this.ttls) {\n      this.initializeTTLTracking()\n    }\n    if (!noUpdateTTL) {\n      this.setItemTTL(index, ttl, start)\n    }\n    this.statusTTL(status, index)\n    if (this.disposeAfter) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift())\n      }\n    }\n    return this\n  }\n\n  newIndex() {\n    if (this.size === 0) {\n      return this.tail\n    }\n    if (this.size === this.max && this.max !== 0) {\n      return this.evict(false)\n    }\n    if (this.free.length !== 0) {\n      return this.free.pop()\n    }\n    // initial fill, just keep writing down the list\n    return this.initialFill++\n  }\n\n  pop() {\n    if (this.size) {\n      const val = this.valList[this.head]\n      this.evict(true)\n      return val\n    }\n  }\n\n  evict(free) {\n    const head = this.head\n    const k = this.keyList[head]\n    const v = this.valList[head]\n    if (this.isBackgroundFetch(v)) {\n      v.__abortController.abort(new Error('evicted'))\n    } else {\n      this.dispose(v, k, 'evict')\n      if (this.disposeAfter) {\n        this.disposed.push([v, k, 'evict'])\n      }\n    }\n    this.removeItemSize(head)\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.keyList[head] = null\n      this.valList[head] = null\n      this.free.push(head)\n    }\n    this.head = this.next[head]\n    this.keyMap.delete(k)\n    this.size--\n    return head\n  }\n\n  has(k, { updateAgeOnHas = this.updateAgeOnHas, status } = {}) {\n    const index = this.keyMap.get(k)\n    if (index !== undefined) {\n      if (!this.isStale(index)) {\n        if (updateAgeOnHas) {\n          this.updateItemAge(index)\n        }\n        if (status) status.has = 'hit'\n        this.statusTTL(status, index)\n        return true\n      } else if (status) {\n        status.has = 'stale'\n        this.statusTTL(status, index)\n      }\n    } else if (status) {\n      status.has = 'miss'\n    }\n    return false\n  }\n\n  // like get(), but without any LRU updating or TTL expiration\n  peek(k, { allowStale = this.allowStale } = {}) {\n    const index = this.keyMap.get(k)\n    if (index !== undefined && (allowStale || !this.isStale(index))) {\n      const v = this.valList[index]\n      // either stale and allowed, or forcing a refresh of non-stale value\n      return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v\n    }\n  }\n\n  backgroundFetch(k, index, options, context) {\n    const v = index === undefined ? undefined : this.valList[index]\n    if (this.isBackgroundFetch(v)) {\n      return v\n    }\n    const ac = new AC()\n    if (options.signal) {\n      options.signal.addEventListener('abort', () =>\n        ac.abort(options.signal.reason)\n      )\n    }\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context,\n    }\n    const cb = (v, updateCache = false) => {\n      const { aborted } = ac.signal\n      const ignoreAbort = options.ignoreFetchAbort && v !== undefined\n      if (options.status) {\n        if (aborted && !updateCache) {\n          options.status.fetchAborted = true\n          options.status.fetchError = ac.signal.reason\n          if (ignoreAbort) options.status.fetchAbortIgnored = true\n        } else {\n          options.status.fetchResolved = true\n        }\n      }\n      if (aborted && !ignoreAbort && !updateCache) {\n        return fetchFail(ac.signal.reason)\n      }\n      // either we didn't abort, and are still here, or we did, and ignored\n      if (this.valList[index] === p) {\n        if (v === undefined) {\n          if (p.__staleWhileFetching) {\n            this.valList[index] = p.__staleWhileFetching\n          } else {\n            this.delete(k)\n          }\n        } else {\n          if (options.status) options.status.fetchUpdated = true\n          this.set(k, v, fetchOpts.options)\n        }\n      }\n      return v\n    }\n    const eb = er => {\n      if (options.status) {\n        options.status.fetchRejected = true\n        options.status.fetchError = er\n      }\n      return fetchFail(er)\n    }\n    const fetchFail = er => {\n      const { aborted } = ac.signal\n      const allowStaleAborted =\n        aborted && options.allowStaleOnFetchAbort\n      const allowStale =\n        allowStaleAborted || options.allowStaleOnFetchRejection\n      const noDelete = allowStale || options.noDeleteOnFetchRejection\n      if (this.valList[index] === p) {\n        // if we allow stale on fetch rejections, then we need to ensure that\n        // the stale value is not removed from the cache when the fetch fails.\n        const del = !noDelete || p.__staleWhileFetching === undefined\n        if (del) {\n          this.delete(k)\n        } else if (!allowStaleAborted) {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          // leave it untouched if we're still waiting for an\n          // aborted background fetch that hasn't yet returned.\n          this.valList[index] = p.__staleWhileFetching\n        }\n      }\n      if (allowStale) {\n        if (options.status && p.__staleWhileFetching !== undefined) {\n          options.status.returnedStale = true\n        }\n        return p.__staleWhileFetching\n      } else if (p.__returned === p) {\n        throw er\n      }\n    }\n    const pcall = (res, rej) => {\n      this.fetchMethod(k, v, fetchOpts).then(v => res(v), rej)\n      // ignored, we go until we finish, regardless.\n      // defer check until we are actually aborting,\n      // so fetchMethod can override.\n      ac.signal.addEventListener('abort', () => {\n        if (\n          !options.ignoreFetchAbort ||\n          options.allowStaleOnFetchAbort\n        ) {\n          res()\n          // when it eventually resolves, update the cache.\n          if (options.allowStaleOnFetchAbort) {\n            res = v => cb(v, true)\n          }\n        }\n      })\n    }\n    if (options.status) options.status.fetchDispatched = true\n    const p = new Promise(pcall).then(cb, eb)\n    p.__abortController = ac\n    p.__staleWhileFetching = v\n    p.__returned = null\n    if (index === undefined) {\n      // internal, don't expose status.\n      this.set(k, p, { ...fetchOpts.options, status: undefined })\n      index = this.keyMap.get(k)\n    } else {\n      this.valList[index] = p\n    }\n    return p\n  }\n\n  isBackgroundFetch(p) {\n    return (\n      p &&\n      typeof p === 'object' &&\n      typeof p.then === 'function' &&\n      Object.prototype.hasOwnProperty.call(\n        p,\n        '__staleWhileFetching'\n      ) &&\n      Object.prototype.hasOwnProperty.call(p, '__returned') &&\n      (p.__returned === p || p.__returned === null)\n    )\n  }\n\n  // this takes the union of get() and set() opts, because it does both\n  async fetch(\n    k,\n    {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,\n      ignoreFetchAbort = this.ignoreFetchAbort,\n      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,\n      fetchContext = this.fetchContext,\n      forceRefresh = false,\n      status,\n      signal,\n    } = {}\n  ) {\n    if (!this.fetchMethod) {\n      if (status) status.fetch = 'get'\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        status,\n      })\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      status,\n      signal,\n    }\n\n    let index = this.keyMap.get(k)\n    if (index === undefined) {\n      if (status) status.fetch = 'miss'\n      const p = this.backgroundFetch(k, index, options, fetchContext)\n      return (p.__returned = p)\n    } else {\n      // in cache, maybe already fetching\n      const v = this.valList[index]\n      if (this.isBackgroundFetch(v)) {\n        const stale =\n          allowStale && v.__staleWhileFetching !== undefined\n        if (status) {\n          status.fetch = 'inflight'\n          if (stale) status.returnedStale = true\n        }\n        return stale ? v.__staleWhileFetching : (v.__returned = v)\n      }\n\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      const isStale = this.isStale(index)\n      if (!forceRefresh && !isStale) {\n        if (status) status.fetch = 'hit'\n        this.moveToTail(index)\n        if (updateAgeOnGet) {\n          this.updateItemAge(index)\n        }\n        this.statusTTL(status, index)\n        return v\n      }\n\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = this.backgroundFetch(k, index, options, fetchContext)\n      const hasStale = p.__staleWhileFetching !== undefined\n      const staleVal = hasStale && allowStale\n      if (status) {\n        status.fetch = hasStale && isStale ? 'stale' : 'refresh'\n        if (staleVal && isStale) status.returnedStale = true\n      }\n      return staleVal ? p.__staleWhileFetching : (p.__returned = p)\n    }\n  }\n\n  get(\n    k,\n    {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status,\n    } = {}\n  ) {\n    const index = this.keyMap.get(k)\n    if (index !== undefined) {\n      const value = this.valList[index]\n      const fetching = this.isBackgroundFetch(value)\n      this.statusTTL(status, index)\n      if (this.isStale(index)) {\n        if (status) status.get = 'stale'\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.delete(k)\n          }\n          if (status) status.returnedStale = allowStale\n          return allowStale ? value : undefined\n        } else {\n          if (status) {\n            status.returnedStale =\n              allowStale && value.__staleWhileFetching !== undefined\n          }\n          return allowStale ? value.__staleWhileFetching : undefined\n        }\n      } else {\n        if (status) status.get = 'hit'\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching\n        }\n        this.moveToTail(index)\n        if (updateAgeOnGet) {\n          this.updateItemAge(index)\n        }\n        return value\n      }\n    } else if (status) {\n      status.get = 'miss'\n    }\n  }\n\n  connect(p, n) {\n    this.prev[n] = p\n    this.next[p] = n\n  }\n\n  moveToTail(index) {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.tail) {\n      if (index === this.head) {\n        this.head = this.next[index]\n      } else {\n        this.connect(this.prev[index], this.next[index])\n      }\n      this.connect(this.tail, index)\n      this.tail = index\n    }\n  }\n\n  get del() {\n    deprecatedMethod('del', 'delete')\n    return this.delete\n  }\n\n  delete(k) {\n    let deleted = false\n    if (this.size !== 0) {\n      const index = this.keyMap.get(k)\n      if (index !== undefined) {\n        deleted = true\n        if (this.size === 1) {\n          this.clear()\n        } else {\n          this.removeItemSize(index)\n          const v = this.valList[index]\n          if (this.isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('deleted'))\n          } else {\n            this.dispose(v, k, 'delete')\n            if (this.disposeAfter) {\n              this.disposed.push([v, k, 'delete'])\n            }\n          }\n          this.keyMap.delete(k)\n          this.keyList[index] = null\n          this.valList[index] = null\n          if (index === this.tail) {\n            this.tail = this.prev[index]\n          } else if (index === this.head) {\n            this.head = this.next[index]\n          } else {\n            this.next[this.prev[index]] = this.next[index]\n            this.prev[this.next[index]] = this.prev[index]\n          }\n          this.size--\n          this.free.push(index)\n        }\n      }\n    }\n    if (this.disposed) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift())\n      }\n    }\n    return deleted\n  }\n\n  clear() {\n    for (const index of this.rindexes({ allowStale: true })) {\n      const v = this.valList[index]\n      if (this.isBackgroundFetch(v)) {\n        v.__abortController.abort(new Error('deleted'))\n      } else {\n        const k = this.keyList[index]\n        this.dispose(v, k, 'delete')\n        if (this.disposeAfter) {\n          this.disposed.push([v, k, 'delete'])\n        }\n      }\n    }\n\n    this.keyMap.clear()\n    this.valList.fill(null)\n    this.keyList.fill(null)\n    if (this.ttls) {\n      this.ttls.fill(0)\n      this.starts.fill(0)\n    }\n    if (this.sizes) {\n      this.sizes.fill(0)\n    }\n    this.head = 0\n    this.tail = 0\n    this.initialFill = 1\n    this.free.length = 0\n    this.calculatedSize = 0\n    this.size = 0\n    if (this.disposed) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift())\n      }\n    }\n  }\n\n  get reset() {\n    deprecatedMethod('reset', 'clear')\n    return this.clear\n  }\n\n  get length() {\n    deprecatedProperty('length', 'size')\n    return this.size\n  }\n\n  static get AbortController() {\n    return AC\n  }\n  static get AbortSignal() {\n    return AS\n  }\n}\n\nexport default LRUCache\n"],"names":["swapNeeded","ab","ArrayBuffer","u8","Uint8Array","u16","Uint16Array","Error","ntoh16","data","i","length","_a","defaultOptions","timeout","maxPageSize","cacheSize","headers","SYNC","debugOptions","SQLITE_DEBUG","process","env","debugSys","debug","d","includes","console","bind","perf","performance","now","Date","AC","AbortController","constructor","this","signal","AS","abort","reason","aborted","dispatchEvent","type","target","hasAbortSignal","AbortSignal","hasACAbortSignal","undefined","_listeners","e","onabort","forEach","f","addEventListener","ev","fn","push","removeEventListener","filter","warned","Set","deprecatedOption","opt","instead","code","shouldWarn","warn","LRUCache","deprecatedMethod","method","prototype","get","Object","getOwnPropertyDescriptor","emitWarning","a","error","has","what","add","isPosInt","n","Math","floor","isFinite","getUintArray","max","pow","Uint32Array","Number","MAX_SAFE_INTEGER","ZeroArray","Array","size","super","fill","Stack","UintArray","heap","pop","options","ttl","ttlResolution","ttlAutopurge","updateAgeOnGet","updateAgeOnHas","allowStale","dispose","disposeAfter","noDisposeOnSet","noUpdateTTL","maxSize","maxEntrySize","sizeCalculation","fetchMethod","fetchContext","noDeleteOnFetchRejection","noDeleteOnStaleGet","allowStaleOnFetchRejection","allowStaleOnFetchAbort","ignoreFetchAbort","maxAge","stale","TypeError","keyMap","Map","keyList","valList","next","prev","head","tail","free","initialFill","disposed","initializeSizeTracking","initializeTTLTracking","getRemainingTTL","key","Infinity","ttls","starts","setItemTTL","index","start","t","setTimeout","isStale","delete","unref","updateItemAge","statusTTL","status","cachedNow","getNow","remainingTTL","_index","_status","_ttl","_start","calculatedSize","sizes","removeItemSize","requireSize","k","v","isBackgroundFetch","addItemSize","evict","entrySize","totalCalculatedSize","_size","_k","_v","indexes","isValidIndex","rindexes","entries","rentries","keys","rkeys","values","rvalues","Symbol","iterator","find","getOptions","value","__staleWhileFetching","thisp","call","rforEach","prune","purgeStale","deleted","dump","arr","entry","age","unshift","load","clear","set","_reason","maxEntrySizeExceeded","newIndex","moveToTail","oldVal","__abortController","oldValue","shift","val","peek","backgroundFetch","context","ac","fetchOpts","cb","updateCache","ignoreAbort","fetchAborted","fetchError","fetchAbortIgnored","fetchResolved","p","fetchUpdated","fetchFail","er","allowStaleAborted","noDelete","returnedStale","__returned","fetchDispatched","Promise","res","rej","then","fetchRejected","hasOwnProperty","fetch","forceRefresh","hasStale","staleVal","fetching","connect","del","reset","field","deprecatedProperty"],"sourceRoot":""}