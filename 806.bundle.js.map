{"version":3,"file":"806.bundle.js","mappings":"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","sources":["webpack://ol-mbtiles/webpack/runtime/chunk loaded","webpack://ol-mbtiles/webpack/runtime/startup chunk dependencies","webpack://ol-mbtiles/./node_modules/sqlite-wasm-http/dist/vfs-http-worker.js","webpack://ol-mbtiles/webpack/bootstrap","webpack://ol-mbtiles/webpack/runtime/define property getters","webpack://ol-mbtiles/webpack/runtime/ensure chunk","webpack://ol-mbtiles/webpack/runtime/get javascript chunk filename","webpack://ol-mbtiles/webpack/runtime/global","webpack://ol-mbtiles/webpack/runtime/hasOwnProperty shorthand","webpack://ol-mbtiles/webpack/runtime/publicPath","webpack://ol-mbtiles/webpack/runtime/importScripts chunk loading","webpack://ol-mbtiles/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(917).then(next);\n};","// This is the entry point for an HTTP backend thread\n// It can serve multiple SQLite worker threads\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport LRUCache from 'lru-cache';\nimport * as VFSHTTP from './vfs-http-types.js';\nimport { ntoh16 } from './endianness.js';\nimport { debug } from './vfs-http-types.js';\nlet options;\n// The set of sqlite Workers that use this backend\nconst consumers = {};\nconst files = new LRUCache({\n    max: 32\n});\n// The entry for a given page can be either the page itself\n// or the number of the page that has the parent super-page\n// Here is an example of a cache structure (indexed by the URL + page number)\n// URL|0 -> Uint8Array(page)                     # This page is in cache\n// URL|1 -> undefined                            # These two\n// URL|2 -> undefined                            # are not\n// URL|3 -> Promise<Uint8Array(page * 2)>        # This is a currently downloading 2-page segment\n// URL|4 -> Promise<3>                           # This references the previous one\n// URL|5 -> 2                                    # An invalid stale entry that will be overwritten\nlet cache;\nlet nextId = 1;\nconst backendAsyncMethods = {\n    // HTTP is a stateless protocol, so xOpen means verify if the URL is valid\n    xOpen: function (msg) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let entry = files.get(msg.url);\n            if (entry instanceof Promise)\n                entry = yield entry;\n            if (entry !== undefined)\n                return 0;\n            // Set a promise for the next opener of the same file to await upon\n            entry = fetch(msg.url, { method: 'HEAD', headers: Object.assign({}, options === null || options === void 0 ? void 0 : options.headers) })\n                .then((head) => {\n                var _a;\n                if (head.headers.get('Accept-Ranges') !== 'bytes') {\n                    console.warn(`Server for ${msg.url} does not advertise 'Accept-Ranges'. ` +\n                        'If the server supports it, in order to remove this message, add \"Accept-Ranges: bytes\". ' +\n                        'Additionally, if using CORS, add \"Access-Control-Expose-Headers: *\".');\n                }\n                return {\n                    url: msg.url,\n                    id: nextId++,\n                    size: BigInt((_a = head.headers.get('Content-Length')) !== null && _a !== void 0 ? _a : 0),\n                    // This will be determined on the first read\n                    pageSize: null\n                };\n            });\n            files.set(msg.url, entry);\n            // Replace it with the actual entry once resolved\n            files.set(msg.url, yield entry);\n            return 0;\n        });\n    },\n    // There is no real difference between xOpen and xAccess, only the semantics differ\n    xAccess: function (msg, consumer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = new Uint32Array(consumer.shm, 0, 1);\n            try {\n                const r = yield backendAsyncMethods.xOpen(msg, consumer);\n                if (r === 0) {\n                    result[0] = 1;\n                }\n                else {\n                    result[0] = 0;\n                }\n            }\n            catch (_a) {\n                result[0] = 0;\n            }\n            return 0;\n        });\n    },\n    xRead: function (msg, consumer) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function* () {\n            let entry = files.get(msg.url);\n            if (!entry)\n                throw new Error(`File ${msg.url} not open`);\n            if (entry instanceof Promise)\n                entry = yield entry;\n            if (msg.n === undefined || msg.offset === undefined)\n                throw new Error('Mandatory arguments missing');\n            if (!entry.pageSize) {\n                // Determine the page size if we don't know it\n                // It is in two big-endian bytes at offset 16 in what is always the first page\n                entry.pageSize = 1024;\n                const pageDataBuffer = new ArrayBuffer(2);\n                const r = yield backendAsyncMethods.xRead({ msg: 'xRead', url: msg.url, offset: BigInt(16), n: 2 }, { buffer: new Uint8Array(pageDataBuffer) });\n                const pageData = new Uint16Array(pageDataBuffer);\n                if (r !== 0)\n                    return r;\n                ntoh16(pageData);\n                entry.pageSize = pageData[0];\n                debug['vfs'](`page size is ${entry.pageSize}`);\n                if (entry.pageSize != 1024) {\n                    // If the page size is not 1024 we can't keep this \"page\" in the cache\n                    console.warn(`Page size for ${msg.url} is ${entry.pageSize}, recommended size is 1024`);\n                    cache.delete(entry.id + '|0');\n                }\n                if (entry.pageSize > ((_a = options === null || options === void 0 ? void 0 : options.maxPageSize) !== null && _a !== void 0 ? _a : VFSHTTP.defaultOptions.maxPageSize))\n                    throw new Error(`${entry.pageSize} is over the maximum configured ` +\n                        `${(_b = options === null || options === void 0 ? void 0 : options.maxPageSize) !== null && _b !== void 0 ? _b : VFSHTTP.defaultOptions.maxPageSize}`);\n            }\n            const pageSize = BigInt(entry.pageSize);\n            const len = BigInt(msg.n);\n            const page = msg.offset / pageSize;\n            if (page * pageSize !== msg.offset)\n                debug['vfs'](`Read chunk ${msg.offset}:${msg.n} is not page-aligned`);\n            let pageStart = page * pageSize;\n            if (pageStart + pageSize < msg.offset + len)\n                throw new Error(`Read chunk ${msg.offset}:${msg.n} spans across a page-boundary`);\n            const cacheId = entry.id + '|' + page;\n            let data = cache.get(cacheId);\n            if (data instanceof Promise)\n                // This means that another thread has requested this segment\n                data = yield data;\n            if (typeof data === 'number') {\n                debug['cache'](`cache hit (multi-page segment) for ${msg.url}:${page}`);\n                // This page is present as a segment of a super-page\n                const newPageStart = BigInt(data) * pageSize;\n                data = cache.get(entry.id + '|' + data);\n                if (data instanceof Promise)\n                    data = yield data;\n                if (data instanceof Uint8Array) {\n                    // Not all subpages are valid, there are two possible cases\n                    // where a non-valid superpage can be referenced:\n                    // * the superpage was too big to fit in the cache\n                    // * the superpage was evicted before the subsegments\n                    pageStart = newPageStart;\n                }\n                else {\n                    data = undefined;\n                }\n            }\n            if (typeof data === 'undefined') {\n                debug['cache'](`cache miss for ${msg.url}:${page}`);\n                let chunkSize = entry.pageSize;\n                // If the previous page is in the cache, we double the page size\n                // This was the original page merging algorithm implemented by @phiresky\n                let prev = page > 0 && cache.get(entry.id + '|' + (Number(page) - 1));\n                if (prev) {\n                    if (prev instanceof Promise)\n                        prev = yield prev;\n                    if (typeof prev === 'number')\n                        prev = cache.get(entry.id + '|' + prev);\n                    if (prev instanceof Promise)\n                        prev = yield prev;\n                    if (prev instanceof Uint8Array) {\n                        // Valid superpage\n                        chunkSize = prev.byteLength * 2;\n                        debug['cache'](`downloading super page of size ${chunkSize}`);\n                    }\n                }\n                const pages = chunkSize / entry.pageSize;\n                // Download a new segment\n                debug['http'](`downloading page ${page} of size ${chunkSize} starting at ${pageStart}`);\n                const resp = fetch(msg.url, {\n                    method: 'GET',\n                    headers: Object.assign(Object.assign({}, ((_c = options === null || options === void 0 ? void 0 : options.headers) !== null && _c !== void 0 ? _c : VFSHTTP.defaultOptions.headers)), { 'Range': `bytes=${pageStart}-${pageStart + BigInt(chunkSize - 1)}` })\n                })\n                    .then((r) => r.arrayBuffer())\n                    .then((r) => new Uint8Array(r));\n                // We synchronously set a Promise in the cache in case another thread\n                // tries to read the same segment\n                cache.set(cacheId, resp);\n                // These point to the parent super-page and resolve at the same time as resp\n                for (let i = Number(page) + 1; i < Number(page) + pages; i++) {\n                    cache.set(entry.id + '|' + i, resp.then(() => Number(page)));\n                }\n                data = yield resp;\n                if (!(data instanceof Uint8Array) || data.length === 0)\n                    throw new Error(`Invalid HTTP response received: ${JSON.stringify(resp)}`);\n                // In case of a multiple-page segment, this is the parent super-page\n                cache.set(cacheId, data);\n                // These point to the parent super-page\n                for (let i = Number(page) + 1; i < Number(page) + pages; i++) {\n                    cache.set(entry.id + '|' + i, Number(page));\n                }\n            }\n            else {\n                debug['cache'](`cache hit for ${msg.url}:${page}`);\n            }\n            const pageOffset = Number(msg.offset - pageStart);\n            consumer.buffer.set(data.subarray(pageOffset, pageOffset + msg.n));\n            return 0;\n        });\n    },\n    // This is cached\n    xFilesize: function (msg, consumer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let entry = files.get(msg.url);\n            if (!entry)\n                throw new Error(`File ${msg.fid} not open`);\n            if (entry instanceof Promise)\n                entry = yield entry;\n            const out = new BigInt64Array(consumer.shm, 0, 1);\n            out[0] = entry.size;\n            return 0;\n        });\n    }\n};\nfunction workMessage({ data }) {\n    return __awaiter(this, void 0, void 0, function* () {\n        debug['threads']('Received new work message', this, data);\n        let r;\n        try {\n            r = yield backendAsyncMethods[data.msg](data, this);\n            debug['threads']('operation successful', this, r);\n            Atomics.store(this.lock, 0, r);\n        }\n        catch (e) {\n            console.error(e);\n            Atomics.store(this.lock, 0, 1);\n        }\n        Atomics.notify(this.lock, 0);\n    });\n}\nglobalThis.onmessage = ({ data }) => {\n    var _a, _b, _c, _d;\n    debug['threads']('Received new control message', data);\n    switch (data.msg) {\n        case 'handshake':\n            {\n                const shm = new SharedArrayBuffer(((_a = options === null || options === void 0 ? void 0 : options.maxPageSize) !== null && _a !== void 0 ? _a : VFSHTTP.defaultOptions.maxPageSize)\n                    + Int32Array.BYTES_PER_ELEMENT);\n                const lock = new Int32Array(shm, ((_b = options === null || options === void 0 ? void 0 : options.maxPageSize) !== null && _b !== void 0 ? _b : VFSHTTP.defaultOptions.maxPageSize));\n                const buffer = new Uint8Array(shm, 0, ((_c = options === null || options === void 0 ? void 0 : options.maxPageSize) !== null && _c !== void 0 ? _c : VFSHTTP.defaultOptions.maxPageSize));\n                Atomics.store(lock, 0, VFSHTTP.SYNC.HANDSHAKE);\n                consumers[data.id] = { id: data.id, port: data.port, shm, lock, buffer };\n                data.port.onmessage = workMessage.bind(consumers[data.id]);\n                postMessage({ msg: 'ack', id: data.id, shm, lock });\n            }\n            break;\n        case 'init':\n            options = data.options;\n            cache = new LRUCache({\n                maxSize: ((_d = options === null || options === void 0 ? void 0 : options.cacheSize) !== null && _d !== void 0 ? _d : VFSHTTP.defaultOptions.cacheSize) * 1024,\n                sizeCalculation: (value) => { var _a; return (_a = value.byteLength) !== null && _a !== void 0 ? _a : 4; }\n            });\n            break;\n        case 'close':\n            postMessage({ msg: 'ack' });\n            close();\n            break;\n        default:\n            throw new Error(`Invalid message received by backend: ${data}`);\n    }\n};\nif (typeof SharedArrayBuffer === 'undefined') {\n    throw new Error('SharedArrayBuffer is not available. ' +\n        'If your browser supports it, the webserver must send ' +\n        '\"Cross-Origin-Opener-Policy: same-origin \"' +\n        'and \"Cross-Origin-Embedder-Policy: require-corp\" headers.');\n}\n//# sourceMappingURL=vfs-http-worker.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [917], () => (__webpack_require__(5806)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".bundle.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t806: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkol_mbtiles\"] = self[\"webpackChunkol_mbtiles\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["deferred","next","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","e","rejected","result","done","then","apply","options","consumers","files","max","cache","nextId","backendAsyncMethods","xOpen","msg","this","entry","get","url","undefined","fetch","method","headers","Object","assign","head","_a","console","warn","id","size","BigInt","pageSize","set","xAccess","consumer","Uint32Array","shm","r","xRead","_b","_c","Error","n","offset","pageDataBuffer","ArrayBuffer","buffer","Uint8Array","pageData","Uint16Array","delete","maxPageSize","len","page","pageStart","cacheId","data","newPageStart","chunkSize","prev","Number","byteLength","pages","resp","arrayBuffer","i","length","JSON","stringify","pageOffset","subarray","xFilesize","fid","BigInt64Array","workMessage","Atomics","store","lock","error","notify","globalThis","onmessage","_d","SharedArrayBuffer","Int32Array","BYTES_PER_ELEMENT","HANDSHAKE","port","bind","postMessage","maxSize","cacheSize","sizeCalculation","close","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","x","__webpack_exports__","O","chunkIds","fn","priority","notFulfilled","Infinity","j","keys","every","key","splice","d","definition","o","defineProperty","enumerable","f","chunkId","all","reduce","promises","u","g","Function","window","obj","prop","prototype","hasOwnProperty","call","scriptUrl","importScripts","location","document","currentScript","src","scripts","getElementsByTagName","test","replace","p","installedChunks","chunkLoadingGlobal","self","parentChunkLoadingFunction","push","moreModules","runtime","pop"],"sourceRoot":""}